<!--

This is the jQuery plugin for Hobo.  This plugin provides the jQuery UI widgets in a Hobo friendly manner, provides useful tags and functions for jQuery javascript coding, and provides additional composite tags.

To use, see the [installation instructions](README.html)

The jQuery UI tags support all of the [options that the corresponding jQuery UI widgets provide](http://docs.jquery.com/UI).  For example:

    <hjq-datepicker dateFormat="yy-mm-dd" />

Options that expect a type other than string can be provided by passing a ruby object:

    <hjq-datepicker dayNamesMin="&['Di', 'Lu', 'Ma', 'Me', 'Je', 'Ve', 'Sa']" />

Events are also supported.  Pass in a global Javascript function name:

    <hjq-datepicker onSelect="hjq.log" />

-->

<!--
This is Hobo jQuery's standard tag annotation method.   This annotation is automatically added to Hobo jQuery tags, but you may wish to use it in your own tag definitions.

The current implementation uses HTML comments for annotation.  This may change in the future, if somebody can suggest a better mechanism.  [Here is a good discussion of the alternatives.](http://www.1729.com/blog/HtmlAnnotations.html).  Two more possibilities are http://www.w3.org/TR/xhtml-rdfa-primer and http://ejohn.org/blog/html-5-data-attributes/.

To use it, invoke this tag directly before the tag to annotate.  To get the annotations, call hjq.getAnnotations with _this_ set to the element that has been annotated.  For example:

    <def tag="mytag">
      <annotate-tag option_a="42"/>
      <div class="hjq-annotated">
        ...
      </div>
    </def>

    jQuery(this).find('.hjq-annotated').each(function() {
      var annotations = hjq.getAnnotations.call(this);
      ...
    });
-->
<def tag="annotate-tag">
  <%= "<!-- json_annotation (#{attributes.to_json}); -->" %>
</def>

<!--
These are the Hobo jQuery and jQuery assets required by Hobo jQuery.  You will probably wish to add this to your page definition:

    <extend tag="page">
      <old-page merge>
        <custom-scripts:>
          <hjq-assets/>
        </custom-scripts>
      </old-page>
    </extend>
-->
<def tag="hjq-assets">
  <jquery-assets/>
  <hobo-jquery-assets/>
</def>

<def tag="jquery-assets">
  <stylesheet name='smoothness/jquery-ui-1.7.custom.css' />
  <javascript name="jquery-1.3.2.min.js" />
  <javascript name="jquery-ui-1.7.custom.min.js" />
</def>

<def tag="hobo-jquery-assets">
  <stylesheet name='hobo-jquery.css' />
  <javascript name="hobo-jquery.js" />
  <script type="text/javascript">
    jQuery.noConflict();
    jQuery(document).ready(function() {
      hjq.initialize.call(document);
    });
  </script>
</def>


<!--
This is the [jQuery-UI datepicker](http://docs.jquery.com/UI/Datepicker).

It's probably easiest to add this to your application.dryml:

    <def tag="input" for="Date">
      <hjq-datepicker dateFormat="yy-mm-dd" merge />
    </def>

It's probably useful to set global options such as dateFormat in application.dryml and set local options such as yearRange in the tag invocation:

    <input:birthdate yearRange="1900:#{Date.today.year}" />

-->
<def attrs="name, altField, altFormat, appendText, buttonImage, buttonImageOnly, buttonText, changeMonth, changeYear, closeText, constrainInput, currentText, dateFormat, dayNames, dayNamesMin, dayNamesShort, defaultDate, duration, firstDay, gotoCurrent, hideIfNoPrevNext, isRTL, maxDate, minDate, monthNames, monthNamesShort, navigationAsDateFormat, nextText, numberOfMonths, prevText, shortYearCutoff, showAnim, showButtonPanel, showCurrentAtPos, showMonthAfterYear, showOn, showOptions, showOtherMonths, stepMonths, yearRange, beforeShow, beforeShowDay, onChangeMonthYear, onClose, onSelect" tag="hjq-datepicker">
 <% option_names=['altField', 'altFormat', 'appendText', 'buttonImage', 'buttonImageOnly', 'buttonText', 'changeMonth', 'changeYear', 'closeText', 'constrainInput', 'currentText', 'dateFormat', 'dayNames', 'dayNamesMin', 'dayNamesShort', 'defaultDate', 'duration', 'firstDay', 'gotoCurrent', 'hideIfNoPrevNext', 'isRTL', 'maxDate', 'minDate', 'monthNames', 'monthNamesShort', 'navigationAsDateFormat', 'nextText', 'numberOfMonths', 'prevText', 'shortYearCutoff', 'showAnim', 'showButtonPanel', 'showCurrentAtPos', 'showMonthAfterYear', 'showOn', 'showOptions', 'showOtherMonths', 'stepMonths', 'yearRange'] %>
 <% event_names=['beforeShow', 'beforeShowDay', 'onChangeMonthYear', 'onClose', 'onSelect'] %>
 <% options = {}; option_names.each {|n| options[n]=all_attributes[n] if all_attributes.has_key?(n) }  %>
 <% events = {}; event_names.each {|n| events[n]=all_attributes[n] if all_attributes.has_key?(n) } %>
 <annotate-tag tag="hjq-datepicker" init="hjq.datepicker.init" options="&options" events="&events" />
 <% add_classes!(attributes, "hjq-annotated"); %>
 <%= text_field_tag(name, this, attributes) %>
</def>



<!-- Creates a sub-section of the form which the user can repeat using (+) and (-) buttons, in order to allow an entire `has_many` collection to be created/edited in a single form.

This tag is similar to the standard Hobo `<input-many>` tag, but it includes several additional features.

 - it supports 0 length associations
 - it supports delayed initialization, required for some Javascript elements like the jQuery UI datepicker
 - it allows the (+) and (-) buttons to be customized
 - it provides a default for then `item` parameter
 - it copies from a template rather than cloning the current item and clearing it
 - the template may be overridden
 - javascript hooks for (+) and (-)

It also fixes the following buglets in input-many:
 - id's of textareas and selects and other non-input's are adjusted properly
 - classdata for inner elements updated
 - the original input-many didn't clear textareas and select's.  We don't have a clear -> no buglet! :)

Because this implementation contains more than one parameter, the default parameter from input-many has been renamed to `item`.
 
### Example

Say you are creating a new `Category` in your online shop, and you want to create some initial products *in the same form*, you can add the following to your form:

    <hjq-input-many:products fields="name, price" />
    
You'll often want to provide the `item` parameter:

    <hjq-input-many:products><item:><field-list fields="name, price" /></item:></hjq-input-many>

### Attributes

 - minimum: the minimum number of items in the collection.  Currently only '0' and '1' are supported values.  The default is '0'.

 - fields: passed down to the `field-list` tag in the default `item`.

 - template: the default values for new items.  Normally this functionality is better provided by Model.new, but it's here if you need it.

 - add-hook: a javascript function to call after an item has been added.  The context will be set to the new item.

 - remove-hook: a javascript function to call before an item is removed.  The context will be set to the item.  If the hook returns false, the remove is cancelled.

### TODO

 - slide effect

  -->
<def tag="hjq-input-many" attrs="minimum, fields, new-template, remove-hook" polymorphic >
<%
# helper function to create id's on buttons to facilitate testing
def underize(s)
  s.gsub(/\[/,"_").gsub(/\]/,"")
end
%>
  <set empty="&this.empty?"/>
  <annotate-tag tag="hjq-input-many" init="hjq.input_many.init" merge-attrs="minimum, add-hook, remove-hook" />
  <ul class="hjq-input-many #{this_field.dasherize} #{css_data :input_many_prefix, param_name_for_this} hjq-annotated">
    <% template ||= this.try.new_candidate || this.member_class.new %>
    <% minimum ||= 0 ; minimum = minimum.to_i %>
    <fake-field-context fake-field="-1" context="&template">
      <li class="input-many-template" id="#{param_name_for_this}">
        <hjq-input-many-item param="item" merge-attrs="fields" />
        <div class="buttons">
          <button param="remove-item" id="#{underize param_name_for_this}_remove">-</button>
          <button param="add-item" id="#{underize param_name_for_this}_add">+</button>
        </div>
      </li>
    </fake-field-context>
    <li class="empty #{'hidden' unless this.empty? and minimum==0}" id="#{param_name_for_this}[-1]_empty">
      <!-- HACK way to signal an empty collection to the controller -->
      <input type="hidden" class="empty-input" id="#{param_name_for_this}" name="#{param_name_for_this}" value="" disabled="&(!this.empty? || minimum>0)" />
      <fake-field-context fake-field="-1" context="&template">
        <div param="empty-message">
          No <%= this.class.class_name.humanize.downcase.pluralize %>.
        </div>
        <div class="buttons">
          <button param="remove-item" class="hidden" id="#{underize param_name_for_this}_remove">-</button>
          <button param="add-item" id="#{underize param_name_for_this}_add">+</button>
        </div>
      </fake-field-context>      
    </li>
    <fake-field-context fake-field="0" context="&template">
      <li if="&(this_parent.empty? && minimum>0)" id="#{param_name_for_this}">
        <hjq-input-many-item param="item" merge-attrs="fields" />
        <div class="buttons">
          <button param="remove-item" class="hidden" id="#{underize param_name_for_this}_remove">-</button>
          <button param="add-item" id="#{underize param_name_for_this}_add">+</button>
        </div>
      </li>
    </fake-field-context>       
    <li repeat class="#{'record-with-errors' unless this.errors.empty?}" id="#{param_name_for_this}">
      <error-messages without-heading class="sub-record"/>
      <hidden-id-field/>
      <hjq-input-many-item param="item" merge-attrs="fields" />
      <div class="buttons">
        <button param="remove-item" class="#{'hidden' if this_parent.length<=minimum}" id="#{underize param_name_for_this}_remove">-</button>
        <button param="add-item" class="#{'hidden' if not last_item?}" id="#{underize param_name_for_this}_add">+</button>
      </div>
    </li>
  </ul>
</def>

<!--
    This is the default item used by `<hjq-input-many>`.  Redefine or extend if desired.
-->
<def tag="hjq-input-many-item" attrs="fields">
  <card param="default">
    <header: replace />
    <body:><field-list merge-attrs="fields" /></body:>
  </card>
</def>